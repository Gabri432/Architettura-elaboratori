## Dynamic Multiple Issue
- I processori nella sono noti anche come processori `superscalari`. Nella versione più semplice le istruzioni sono rilasciate in ordine e il processore decide quante istruzioni rilasciare in un dato ciclo di clock;
- Una delle più importanti differenze rispetto alla static issue è che il codice, schedulato o meno, è garantito di venir eseguito correttamente dall'hardware. Inoltre il codice compilato potrà funzionare sempre correttamente indipendentemente dalla frequenza di rilascio o dalla struttura della pipeline di un processore. In VLIW talvolta era necessaria una ricompilazione quando ci si muoveva attraverso diversi modelli di processori.

## Dynamic pipelining scheduling
- La schedulazione dinamica della pipeline sceglie quali istruzioni sono le prossime da eseguire, possibilmente riordinandole per evitare stalli. In questi processori la pipeline è divisa in 3 principali unità: l'unità di `instruction fetch and issue`, le unità  `funzionali (functional unit)` e l'unità di  `commit`;
- La prima unità prende le istruzioni, le decodifica e manda ciascuna istruzione all'unità funzionale corrispondente. Ciascuna di esse ha dei buffer, detti `reservation stations`, che trattengono gli operandi e l'operazione;
- Dal momemnto in cui il buffer contiene tutti gli operandi e l'unità funzionale è pronta all'esecuzione il risultato viene calcolato. Al termine di ciò il risultato viene mandato alla reservation station che lo richiedeva o alla commit unit, che lo salva in un buffer fino a quando risulta sicuro mandarlo nel register file o in memoria;
- Tale buffer, `reorder buffer` viene usato anche per fornire operandi, ed una volta che il risultato è commissionato al register file può venire direttamente acquisito da questo buffer.
- Con questa tecnica in pratica si analizza la struttura del flusso di dati di un programma, quindi il processore esegue le istruzioni in modo tale da preservare tale flusso. Tale modo è detto `out-of-order execution`, poichè le istruzioni possono venire eseguite in un ordine diverso da quello di acquisizione;
- Nella `in-order commit` invece l'unità di instruction fetch and decode deve rilasciare le istruzioni in ordine, così da permettere la tracciabilità delle dipendenze, e l'unità di commit unit deve scrivere i risultati nei registri e in memoria nell'ordine di acquisizione del programma.